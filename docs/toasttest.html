<!DOCTYPE html>
<html>
<head>
<link href='https://fonts.googleapis.com/css?family=Roboto Condensed' rel='stylesheet'>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>

body {
	margin-top: 1cm;
	margin-left: 4cm;
	margin-right: 4cm;
	padding: 0;
        font-size: 15px;
        font-family: 'Roboto Condensed', 'Tahoma', 'Arial', sans-serif;
}

   ul.tree a {
    color: back;
    text-decoration: none;
    display: block;
    width: 100%;
   }
   ul.tree a:hover {
    background: lightgray;
    text-decoration: none;
    display: inline-block;
    width: 100%;
   }

   li {
     list-style-type: none;
     background:  repeat-y;
     padding: 0;
   }


   ul.tree, ul.tree ul {
     list-style-type: none;
     background:  repeat-y;
     margin: 0;
     padding: 0;
     margin: 5px;
   }

   ul.tree ul {
     list-style-type: none;
     margin-left: 10px;
   }


a {
    color: black;
}

   ul.tree li {
     margin: 5px;
     padding: 0 12px;
     line-height: 20px;
     color: #369;
   }

   ul.tree li.last {
     background: #fff url(images/lastnode.png) no-repeat;
   }

ul.topnav {
    list-style-type: none;
    padding: 0;
    margin: 0;
    overflow: hidden;
    background-color: #333;
    font-size: 15px;
    text-align: center;
}

ul.topnav li {float: left;}

img.logo {max-width: 350px;}

ul.topnav li a {
    display: block;
    color: white;
    text-align: center;
    padding: 14px 27px;
    text-decoration: none;
}
ul.topnav li a:hover:not(.active) {background-color: #111;}
ul.topnav li a.active {background-color: #4CAF50;}
ul.topnav li.right {float: right;}
@media screen and (max-width: 600px){
    ul.topnav li.right, 
    ul.topnav li {float: none;}
}

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }

</style>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script>
</head>
<body> 
<img class="logo" src="ValoMC_logo.png">
<ul class="topnav">
<font size="4">
  <li><a href="index.html">Home</a></li>
  <li><a href="download.html">Download</a></li>
  <li><a href="features.html">Features</a></li>
  <li><a href="installation.html">Installation</a></li>
  <li><a class="active" href="documentation.html">Documentation</a></li>
  <li class="right"><a href="about.html">About</a></li>
</font>
</ul>

<div style="padding:0 16px;">
  <h2></h2>
  <p></p>
  <p></p>
<font size="4">
<div style="width: 100%;">
    <div style="width: 300px; float: left;">
<br> 
<li><a>Documentation</a></li>
<ul class="tree">
<li><a href="gettingstarted.html">Getting started</a></li>
<li><a>2D</a></li>
<ul class="tree">
<li><a href="simpletest.html">Simple example</a></li>
<li><a href="inhomogeneous.html">Creating an inhomogeneous medium</a></li>
<li><a href="directingls.html">Directing light sources</a></li>
<li><a href="boundarytest.html">Setting boundary conditions and visualising the boundary solution</a></li>
<li><a href="frequency.html">Frequency domain calculation</a></li>
<li><a href="toasttest.html">Working with Toast</a></li>
<li><a href="netgentest.html">Working with NetGen</a></li>
<li><a href="generatingc.html">Generating input for the external executable</a></li>
<li><a href="pixeltest.html">Working with pixel format data</a></li>
<li><a href="kwavetest.html">Simulating the photoacoustic effect using K-Wave</a></li>
<li><a>Code documentation</a></li>
<ul class="tree">
<li><a href="structures.html">List of structures</a></li>
<li><a href="findingelements.html">Finding elements</a></li>
<li><a href="findingboundaries.html">Finding boundaries</a></li>
</ul></ul>
<li><a>3D</a></li>
<ul class="tree">
<li><a href="voxeltest.html">Working with voxel format data</a></li>
<li><a href="netgentest3d.html">Working with NetGen</a></li>
<li><a href="threedmodel.html">Digimouse example</a></li>
<li><a href="kwavetest3d.html">Simulating the photoacoustic effect using K-Wave</a></li>
<li><a>Code documentation</a></li>
<ul class="tree">
<li><a href="structures3d.html">List of structures</a></li>
<li><a href="findingelements3d.html">Finding elements</a></li>
<li><a href="findingboundaries3d.html">Finding boundaries</a></li>
</ul></ul>
<li><a href="literature.html">Literature</a></li>
<li><a href="functionreference.html">Alphabetical function listing</a></li>
</ul>
    </div>
    <div style="margin-left: 350px; padding: 5px;"> 
<div class="content"><h1>Working with Toast++: toastest.m</h1><!--introduction--><p>This example is based on a simple Toast usage example found on the Toast web site. See <a href="http://web4.cs.ucl.ac.uk/research/vis/toast/demo_matlab_fwd1.html">http://web4.cs.ucl.ac.uk/research/vis/toast/demo_matlab_fwd1.html</a>. It simulates a steady state diffuse optical tomogarphy (DOT) measurement in a circular geometry that has 16 detectors and 16 light sources located on the baoundary of the object. Each source is used to illuminate light into the domain and the amount of light is measured at all detectors. This is repated for all source locations. In the example, the measurement matrix (photon fluence at detectors) is simulated both with Toast (as in the original example) and with PhotonMC. Note that the results are not equal since Toast uses diffusion approximation (DA) as the model for light propagation. The DA can be regarded as a good approximation for photon transport in a highly scattering medium with distances further than a few scattering lengths from the source.</p><p>Toast++ is a software for image reconstruction in diffuse optical tomography. It contains a forward solver module using the finite element method for simulating the propagation of light in highly scattering, inhomogeneous biological tissues. The inverse solver module uses an iterative, model-based approach to reconstruct the unknown distributions of absorption and scattering coefficients in the volume of interest from boundary measurements of transmitted light.</p><p>Toast++ toolbox is being developed by Martin Schweiger and Simon Arridge (University College London) and the copyright of the original code belongs to them.</p><p>Toast homepage: <a href="http://web4.cs.ucl.ac.uk/research/vis/toast/index.html">http://web4.cs.ucl.ac.uk/research/vis/toast/index.html</a>. M. Schweiger and S. R. Arridge, "The Toast++ software suite for forward and inverse modeling in optical tomography", Journal of Biomedical Optics, 19(4):040801, 2014.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Create meshes</a></li><li><a href="#2">Set the optical coefficients</a></li><li><a href="#3">Create the source and detector positions for Toast</a></li><li><a href="#4">Create the source and detector positions for PhotonMC</a></li><li><a href="#5">Plot the source/detector arrangement</a></li><li><a href="#6">Create the source and boundary projection vectors for Toast</a></li><li><a href="#7">Solve the FEM system with Toast</a></li><li><a href="#8">Solve the photon transport problem with PhotonMC</a></li><li><a href="#9">Plot the solutions</a></li><li><a href="#10">Plot the measurement profile as a function of source-detector separation</a></li></ul></div><h2 id="1">Create meshes</h2><p>A circular mesh is created as in the original example and imported to PhotonMC.</p><pre class="codeinput">rad = 25;
nsect = 6;
nring = 32;
nbnd = 2;
[vtx,idx,eltp] = mkcircle(rad,nsect,nring,nbnd);
toast_mesh = toastMesh(vtx,idx,eltp);

<span class="comment">% Use a convenience function provided by PhotonMC to import the Toast</span>
<span class="comment">% finite element mesh.</span>
photonmc_mesh = importToastMesh(toast_mesh);
</pre><h2 id="2">Set the optical coefficients</h2><pre class="codeinput">mua_bkg = 0.01;     <span class="comment">% absorption coefficient [1/mm]</span>
mus_bkg = 1.0;      <span class="comment">% reduced scattering coefficient [1/mm]</span>
ref_bkg = 1.4;      <span class="comment">% refractive index [unitless]</span>

<span class="comment">% In Toast, the optical coefficients are defined for each node</span>
nnd = toast_mesh.NodeCount;
toast_mua = ones(nnd,1) * mua_bkg;  <span class="comment">% absorption coefficient [1/mm]</span>
toast_mus = ones(nnd,1) * mus_bkg;  <span class="comment">% reduced scattering coefficient [1/mm]</span>
toast_ref = ones(nnd,1) * ref_bkg;  <span class="comment">% refractive index [unitless]</span>

<span class="comment">% For PhotonMC, the optical coefficients are for each element</span>
nne = size(photonmc_mesh.H,1); <span class="comment">% number of elements</span>
photonmc_medium.absorption_coefficient = ones(nne,1)*mua_bkg; <span class="comment">% absorption coefficient [1/mm]</span>
photonmc_medium.scattering_coefficient = ones(nne,1)*mus_bkg; <span class="comment">% scattering coefficient [1/mm]</span>
photonmc_medium.refractive_index = ones(nne,1)*ref_bkg;       <span class="comment">% refractive index [unitless]</span>

<span class="comment">% The scattering anisotropy parameter g of the Henyey-Greenstein scattering</span>
<span class="comment">% phase function is set to zero so that the scattering coefficient (used by</span>
<span class="comment">% PhotonMC) and the reduced scattering coefficient (used by Toast) are equal</span>
photonmc_medium.scattering_anisotropy = ones(nne,1)*0.0;      <span class="comment">% scattering anisotropy parameter [unitless]</span>
</pre><h2 id="3">Create the source and detector positions for Toast</h2><pre class="codeinput"><span class="comment">% Sources and detectors are attached to nodes</span>
nq = 16;
<span class="keyword">for</span> ii=1:nq
  phi_q = 2*pi*(ii-1)/nq;
  Q(ii,:) = rad * [cos(phi_q) sin(phi_q)];
  phi_m = 2*pi*(ii-0.5)/nq;
  M(ii,:) = rad * [cos(phi_m) sin(phi_m)];
<span class="keyword">end</span>
toast_mesh.SetQM(Q,M);
</pre><h2 id="4">Create the source and detector positions for PhotonMC</h2><pre class="codeinput"><span class="comment">% The sources and detectors are attached to boundary elements.</span>
<span class="comment">% Keyword 'location' can be used to find the elements that</span>
<span class="comment">% are nearest to the corresponding location vector.</span>
photonmc_source_indices = findBoundaries(photonmc_mesh, <span class="string">'location'</span>, Q);
photonmc_detector_indices = findBoundaries(photonmc_mesh, <span class="string">'location'</span>, M);
photonmc_boundary = createBoundary(photonmc_mesh, photonmc_medium);
</pre><h2 id="5">Plot the source/detector arrangement</h2><pre class="codeinput"><span class="comment">% Note that while the figures resemble closely each other, the sources/detectors</span>
<span class="comment">% in PhotonMC are represented by boundary elements, whereas in Toast setup</span>
<span class="comment">% they are element vertices. The difference becomes smaller with a finer mesh.</span>

figure(<span class="string">'rend'</span>,<span class="string">'painters'</span>,<span class="string">'pos'</span>,[10 10 1200 400])
h = subplot(1,2,1);
hold <span class="string">on</span>
toast_mesh.Display;
h1 = plot(Q(:,1),Q(:,2),<span class="string">'ro'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'r'</span>);
h2 = plot(M(:,1),M(:,2),<span class="string">'bs'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'b'</span>);
legend([h1 h2], {<span class="string">'Sources'</span>, <span class="string">'Detectors'</span>});
title(<span class="string">'Toast source/detector setup'</span>);

hold <span class="string">off</span>
subplot(1,2,2)
hold <span class="string">on</span>
toast_mesh.Display;
<span class="keyword">for</span> ii=1:16 <span class="comment">% size(photonmc_source_indices,1)</span>
    h3=plot(photonmc_mesh.r(photonmc_mesh.BH(photonmc_source_indices(ii),:),1), <span class="keyword">...</span>
            photonmc_mesh.r(photonmc_mesh.BH(photonmc_source_indices(ii),:),2), <span class="string">'r'</span>, <span class="string">'LineWidth'</span>,4.0);
    h4=plot(photonmc_mesh.r(photonmc_mesh.BH(photonmc_detector_indices(ii),:),1), <span class="keyword">...</span>
            photonmc_mesh.r(photonmc_mesh.BH(photonmc_detector_indices(ii),:),2), <span class="string">'b'</span>, <span class="string">'LineWidth'</span>,4.0);
<span class="keyword">end</span>
legend([h3 h4], {<span class="string">'Sources'</span>, <span class="string">'Detectors'</span>});
title(<span class="string">'PhotonMC source/detector setup'</span>);
hold <span class="string">off</span>
</pre><img alt="" hspace="5" src="toasttest_01.png" vspace="5"/> <h2 id="6">Create the source and boundary projection vectors for Toast</h2><pre class="codeinput">gaussian_width = 2;

qvec = toast_mesh.Qvec(<span class="string">'Neumann'</span>, <span class="string">'Gaussian'</span>, gaussian_width);
mvec = toast_mesh.Mvec(<span class="string">'Gaussian'</span>, gaussian_width,toast_ref);
</pre><h2 id="7">Solve the FEM system with Toast</h2><pre class="codeinput">K = dotSysmat (toast_mesh,toast_mua,toast_mus,toast_ref,0);
Phi = K\(2*qvec);
Y = mvec.' * Phi;
</pre><h2 id="8">Solve the photon transport problem with PhotonMC</h2><p>The source is relocated 16 times to simulate photon transport for each source</p><pre class="codeinput">Y2 = ones(nq,nq);
<span class="keyword">for</span> ii=1:nq
   disp([<span class="string">'Starting simulation '</span> num2str(ii) <span class="string">' out of '</span> num2str(nq)]);
   options.photon_count = 1e6;                  <span class="comment">% number of photon packets</span>
   photonmc_boundary.lightsource(:) = {<span class="string">'none'</span>}; <span class="comment">% erase all light sources</span>
   photonmc_boundary.lightsource(photonmc_source_indices(ii)) = {<span class="string">'gaussian'</span>};
   photonmc_boundary.lightsource_gaussian_sigma(photonmc_source_indices(ii)) = gaussian_width;
   photonmc_solution = ValoMC(photonmc_mesh, photonmc_medium, photonmc_boundary,options);
   <span class="comment">% build the solution matrix column by column</span>
   <span class="comment">% Factor of two follows from the boundary conditions</span>
   Y2(:,ii) = photonmc_solution.boundary_fluence(photonmc_detector_indices(:));
<span class="keyword">end</span>
</pre><pre class="codeoutput">Starting simulation 1 out of 16
Initializing MC2D using 16 threads...
Computing... 
...done

Done
Starting simulation 2 out of 16
Initializing MC2D using 16 threads...
Computing... 
...done

Done
Starting simulation 3 out of 16
Initializing MC2D using 16 threads...
Computing... 
...done

Done
Starting simulation 4 out of 16
Initializing MC2D using 16 threads...
Computing... 
...done

Done
Starting simulation 5 out of 16
Initializing MC2D using 16 threads...
Computing... 
...done

Done
Starting simulation 6 out of 16
Initializing MC2D using 16 threads...
Computing... 
...done

Done
Starting simulation 7 out of 16
Initializing MC2D using 16 threads...
Computing... 
...done

Done
Starting simulation 8 out of 16
Initializing MC2D using 16 threads...
Computing... 
...done

Done
Starting simulation 9 out of 16
Initializing MC2D using 16 threads...
Computing... 
...done

Done
Starting simulation 10 out of 16
Initializing MC2D using 16 threads...
Computing... 
...done

Done
Starting simulation 11 out of 16
Initializing MC2D using 16 threads...
Computing... 
...done

Done
Starting simulation 12 out of 16
Initializing MC2D using 16 threads...
Computing... 
...done

Done
Starting simulation 13 out of 16
Initializing MC2D using 16 threads...
Computing... 
...done

Done
Starting simulation 14 out of 16
Initializing MC2D using 16 threads...
Computing... 
...done

Done
Starting simulation 15 out of 16
Initializing MC2D using 16 threads...
Computing... 
...done

Done
Starting simulation 16 out of 16
Initializing MC2D using 16 threads...
Computing... 
...done

Done
</pre><h2 id="9">Plot the solutions</h2><pre class="codeinput">figure(<span class="string">'rend'</span>,<span class="string">'painters'</span>,<span class="string">'pos'</span>,[10 10 1200 400])

subplot(1,2,1)
imagesc(log(Y));
xlabel(<span class="string">'source index q'</span>);
ylabel(<span class="string">'detector index m'</span>);
axis <span class="string">equal</span> <span class="string">tight</span>;
colorbar
title(<span class="string">'Toast result'</span>);

<span class="comment">% Display boundary profile</span>
subplot(1,2,2)
imagesc(log(Y2));
xlabel(<span class="string">'source index q'</span>);
ylabel(<span class="string">'detector index m'</span>);
axis <span class="string">equal</span> <span class="string">tight</span>;
colorbar
title(<span class="string">'PhotonMC result'</span>);

hold <span class="string">off</span>;
</pre><img alt="" hspace="5" src="toasttest_02.png" vspace="5"/> <h2 id="10">Plot the measurement profile as a function of source-detector separation</h2><pre class="codeinput"><span class="comment">% Note that because of the differences between the diffusion approximation</span>
<span class="comment">% and photon transport as well as the stochastic nature of the Monte Carlo</span>
<span class="comment">% simulations, the 16 measurement profiles do not fully coincide.</span>

figure;
hold <span class="string">on</span>
angle = 360/32:360/16:360;
<span class="keyword">for</span> ii=1:1
    ywrap = [Y(ii:end,ii); Y(1:ii-1,ii)];
    h=plot(angle,log(ywrap),<span class="string">'o-'</span>);
<span class="keyword">end</span>
axis([0 360 -15 -2]);
xlabel(<span class="string">'angular source-detector separation'</span>);
ylabel(<span class="string">'log intensity'</span>);

angle = 360/32:360/16:360;
<span class="comment">%for ii=1:size(Y,2)</span>
<span class="keyword">for</span> ii=1:1
    ywrap = [Y2(ii:end,ii); Y2(1:ii-1,ii)];
    h2=plot(angle,log(ywrap),<span class="string">'*-'</span>);
<span class="keyword">end</span>
axis([0 360 -15 -2]);
xlabel(<span class="string">'angular source-detector separation'</span>);
ylabel(<span class="string">'log intensity'</span>);
legend([h h2], {<span class="string">'Toast'</span>, <span class="string">'PhotonMC'</span>});

hold <span class="string">off</span>
</pre><img alt="" hspace="5" src="toasttest_03.png" vspace="5"/> <p class="footer"><br/><a href="http://www.mathworks.com/products/matlab/">Published with MATLABÂ® R2016b</a><br/></p></div>
    </div>
</div>
</font>

  </div>

<br>
<br> </div><footer> <hr> <p>Last updated: Mon May 28 11:28:14 EEST 2018 by aleksle</p></footer> </body> </html>

