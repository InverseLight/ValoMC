<!DOCTYPE html>
<meta charset="UTF-8"> 
<html>
<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-125261808-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-125261808-1');
</script>
<link href='https://fonts.googleapis.com/css?family=Roboto Condensed' rel='stylesheet'>
<style>

body {
  margin-top: 5vw;
  margin-left: 10vw;
  margin-right: 10vw;
   padding: 0;
  font-size: 100%;
  font-family: 'Roboto Condensed', 'Tahoma', 'Arial', sans-serif;
}


   ul.tree a {
    color: back;
    text-decoration: none;
    display: block;
    width: 100%;
   }
   ul.tree a:hover {
    background: lightgray;
    text-decoration: none;
    display: inline-block;
    width: 100%;
   }
img.logo {max-width: 300px;}

   li {
     list-style-type: none;
     background:  repeat-y;
     padding: 0;
   }


   ul.tree, ul.tree ul {
     list-style-type: none;
     background:  repeat-y;
     margin: 0;
     padding: 0;
     margin: 0.1vw;
   }

   ul.tree ul {
     list-style-type: none;
     margin-left: 0.1vw;
   }

ul.tree li {
     margin: 0.1vw;
     padding: 0.1vw 1vw;
     line-height: 100%;
     color: #369;
   }


a {
    color: black;
}


   ul.tree li.last {
     background: #fff url(images/lastnode.png) no-repeat;
   }

   ul.topnav {
    list-style-type: none;
    padding: 0;
    margin: 0;
    overflow: hidden;
    background-color: #333;
    font-size: 1.5vw;
    text-align: center;
}

ul.topnav li {float: left;
     list-style-type: none;
}

ul.topnav li a {
    display: block;
    color: white;
    text-align: center;
    padding: 0.2vw 0.0cm;
    width: 8.5vw;
    text-decoration: none;
    font-size: 1.2vw;
}
ul.topnav li a:hover:not(.active) {background-color: #111;}
ul.topnav li a.active {background-color: #4CAF50;}
ul.topnav li.right {float: right;}


pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }

img.logo {max-width: 25vw;}

.caret {
  cursor: pointer;
  -webkit-user-select: none; /* Safari 3.1+ */
  -moz-user-select: none; /* Firefox 2+ */
  -ms-user-select: none; /* IE 10+ */
  user-select: none;
}

.caret::before {
  content: "\25B6";
  color: black;
  display: inline-block;
  margin-right: 6px;
}

.caret-down::before {
  -ms-transform: rotate(90deg); /* IE 9 */
  -webkit-transform: rotate(90deg); /* Safari */'
  transform: rotate(90deg);  
}

.nested {
  display: none;
}

.active {
  display: block;
}

 ul.tree a:hover {
    background: lightgray;
    text-decoration: none;
    display: inline-block;
    width: 100%;
   }


   ul.simple li {
     list-style-type: square;
     background:  repeat-y;
     padding: 0;
   }


</style>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script>
</head>
<body> 
<img class="logo" src="ValoMC_logo.png">
<ul class="topnav">
<font size="4">
  <li><a href="index.html">Home</a></li>
  <li><a href="download.html">Download</a></li>
  <li><a href="features.html">Features</a></li>
  <li><a href="installation.html">Installation</a></li>
  <li><a class="active" href="documentation.html">Documentation</a></li>
  <li class="right"><a href="about.html">About</a></li>
</font>
</ul>

<div style="padding:0 0vw; width: auto;">
  <h2></h2>
  <p></p>
  <p></p>
<font size="4">
<div class="bottomhalf" style="width: 100%;">
    <div style="width: 20%; float: left;">
<br> 
<ul style="padding: 0 0px" class="tree">
<li>
<span class="caret"> Documentation</span>
<ul class="nested">
<li>
<a href="gettingstarted.html"> Getting started</a>
</li>
<li>
<span class="caret"> 2D Code documentation</span>
<ul class="nested">
<li>
<a href="structures.html"> List of structures</a>
</li>
<li>
<a href="findingelements.html"> Finding elements</a>
</li>
<li>
<a href="findingboundaries.html"> Finding boundaries</a>
</li></ul>
<li>
<span class="caret"> 2D Examples</span>
<ul class="nested">
<li>
<a href="simpletest.html"> Simple example</a>
</li>
<li>
<a href="inhomogeneous.html"> Creating an inhomogeneous medium</a>
</li>
<li>
<a href="directingls.html"> Directing light sources</a>
</li>
<li>
<a href="boundarytest.html"> Setting boundary conditions and visualising the boundary solution</a>
</li>
<li>
<a href="frequency.html"> Frequency domain calculation</a>
</li>
<li>
<a href="netgentest.html"> Working with NetGen</a>
</li>
<li>
<a href="generatingc.html"> Generating input for the external executable</a>
</li>
<li>
<a href="pixeltest.html"> Working with pixel format data</a>
</li>
<li>
<a href="toasttest.html"> Working with Toast++</a>
</li>
<li>
<a href="kwavetest.html"> Simulating the photoacoustic effect using K-Wave</a>
</li></ul>
<li>
<span class="caret"> 3D Code documentation</span>
<ul class="nested">
<li>
<a href="structures3d.html"> List of structures</a>
</li>
<li>
<a href="findingelements3d.html"> Finding elements</a>
</li>
<li>
<a href="findingboundaries3d.html"> Finding boundaries</a>
</li></ul>
<li>
<span class="caret"> 3D Examples</span>
<ul class="nested">
<li>
<a href="voxeltest.html"> Working with voxel format data</a>
</li>
<li>
<a href="netgentest3d.html"> Working with NetGen</a>
</li>
<li>
<a href="threedmodel.html"> Digimouse example</a>
</li></ul>
<li>
<a href="functionreference.html"> Alphabetical function listing</a>
</li></ul>
<li>
<a href="literature.html"> Literature</a>
</li>
</ul>
    </div>
    <div style="margin-left: 20%; padding: 1vw;" class="maintext"> 
<div class="content"><h1>Working with Toast++: toastest.m</h1><!--introduction--><p>This example is based on a simple Toast++ usage example found on the Toast++ web site. The original example can be found from <a href="http://web4.cs.ucl.ac.uk/research/vis/toast/demo_matlab_fwd1.html">http://web4.cs.ucl.ac.uk/research/vis/toast/demo_matlab_fwd1.html</a>. It simulates a steady state diffuse optical tomography (DOT) measurement in a circular geometry that has 16 detectors and 16 light sources located on the boundary of the object.</p><p>Each source is used to illuminate light into the domain and the amount of light is measured at all detectors. This is repeated for all source locations. In the example, the measurement matrix (signal intensity at each detector) is simulated both with Toast (as in the original example) and with ValoMC. Note that the results are not equal since Toast uses DA as the model for light propagation. DA can be regarded as a good approximation for photon transport in a highly scattering medium with distances further than a few scattering lengths from the source.</p><p>Toast++ is a software for image reconstruction in diffuse optical tomography. It contains a forward solver module using the finite element method for simulating the propagation of light in highly scattering, inhomogeneous biological tissues. The inverse solver module uses an iterative, regularized least-squares approach to reconstruct the unknown distributions of absorption and scattering coefficients in the volume of interest from boundary measurements of transmitted light.</p><p>Toast++ toolbox is being developed by Martin Schweiger and Simon Arridge (University College London) and the copyright of the original code belongs to them.</p><p>Toast homepage: <a href="http://web4.cs.ucl.ac.uk/research/vis/toast/index.html">http://web4.cs.ucl.ac.uk/research/vis/toast/index.html</a>. M. Schweiger and S. R. Arridge, "The Toast++ software suite for forwards and inverse modeling in optical tomography", Journal of Biomedical Optics, 19(4):040801, 2014.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Create the geometry</a></li><li><a href="#2">Set the optical coefficients</a></li><li><a href="#3">Create the source and detector positions</a></li><li><a href="#4">Plot the source/detector arrangement</a></li><li><a href="#5">Solve the FEM system with Toast</a></li><li><a href="#6">Solve the photon transport problem with ValoMC</a></li><li><a href="#7">Plot the solutions</a></li><li><a href="#8">Plot the measurement profile as a function of source-detector separation</a></li></ul></div><h2 id="1">Create the geometry</h2><p>Create a circular mesh using Toast++ and import it to ValoMC</p><pre class="codeinput">rad = 25;
nsect = 8;
nring = 34;
nbnd = 2;


[vtx,idx,eltp] = mkcircle(rad,nsect,nring,nbnd);

toastmesh = toastMesh(vtx,idx,eltp);
vmcmesh = importToastMesh(toastmesh);
</pre><h2 id="2">Set the optical coefficients</h2><p>Note that the optical coefficients are given for each node in Toast, whereas in ValoMC they are uniform values for each element.</p><pre class="codeinput"><span class="comment">% absorption coefficient [1/mm]</span>
mua_bkg = 0.01;
<span class="comment">% scattering coefficient [1/mm]</span>
mus_bkg = 1.0;
<span class="comment">% scattering anisotropy parameter [unitless]</span>
scattering_anisotropy_bkg = 0.0;
<span class="comment">% reduced scattering coefficient [1/mm]</span>
mus_reduced = mus_bkg*(1-scattering_anisotropy_bkg);

<span class="comment">% Set optical coefficients for Toast.</span>

nnd = toastmesh.NodeCount;
toast_mua = ones(nnd,1) * mua_bkg;  <span class="comment">% absorption coefficient [1/mm]</span>
toast_mus = ones(nnd,1) * mus_reduced; <span class="comment">% reduced scattering coefficient [1/mm]</span>

<span class="comment">% Set optical coefficients for ValoMC. The refractive index is set but it</span>
<span class="comment">% does not affect the solution as there is no mismatch on the boundary.</span>

nne = size(vmcmesh.H,1); <span class="comment">% number of elements</span>

<span class="comment">% absorption coefficient [1/mm]</span>
vmcmedium.absorption_coefficient = ones(nne,1)*mua_bkg;
 <span class="comment">% scattering coefficient [1/mm]</span>
vmcmedium.scattering_coefficient = ones(nne,1)*mus_bkg;
 <span class="comment">% refractive index [unitless]</span>
vmcmedium.refractive_index = ones(nne,1)*1;
<span class="comment">% scattering anisotropy parameter [unitless]</span>
vmcmedium.scattering_anisotropy = ones(nne,1)*scattering_anisotropy_bkg;

<span class="comment">% Create the boundary so that there is no mismatch</span>
vmcboundary = createBoundary(vmcmesh, vmcmedium);
</pre><h2 id="3">Create the source and detector positions</h2><p>A collimated lightsoure (pencil beam) can be approximated in DA by placing an isotropic source at a distance 1/mus' from the surface, where mus' is the reduced scattering coefficient.</p><pre class="codeinput"><span class="comment">% Build source/detector locations for Toast</span>

nq = 16;
<span class="keyword">for</span> ii=1:nq
  phi_q = 2*pi*(ii-1)/nq + pi / 256;
  Q(ii,:) = (rad - 1/mus_reduced) * [cos(phi_q) sin(phi_q)]; <span class="comment">% source position</span>
  phi_m = 2*pi*(ii-0.5)/nq + pi / 256;
  M(ii,:) = rad * [cos(phi_m) sin(phi_m)]; <span class="comment">% detector position</span>
<span class="keyword">end</span>

toastmesh.SetQM(Q,M);


<span class="comment">% Build source/detector locations for ValoMC</span>

<span class="comment">% Sources and detectors are placed to the nearest boundary elements</span>

source_boundary_elements = findBoundaries(vmcmesh, <span class="string">'location'</span>, Q);
detector_boundary_elements = findBoundaries(vmcmesh, <span class="string">'location'</span>, M);
</pre><h2 id="4">Plot the source/detector arrangement</h2><p>Note that the lightsources have a finite width in ValoMC, which introduces a small discretisation error in the comparison.</p><pre class="codeinput">figure(<span class="string">'rend'</span>,<span class="string">'painters'</span>,<span class="string">'pos'</span>,[10 10 1000 1000])
hold <span class="string">on</span>
patch(<span class="string">'Faces'</span>, vmcmesh.H, <span class="string">'Vertices'</span>,vmcmesh.r, <span class="string">'FaceVertexCData'</span>, 0, <span class="string">'FaceColor'</span>, <span class="string">'flat'</span>, <span class="string">'LineWidth'</span>, 0.1);

<span class="keyword">for</span> ii=1:nq
    h1=plot(vmcmesh.r(vmcmesh.BH(source_boundary_elements(ii),:),1), <span class="keyword">...</span>
            vmcmesh.r(vmcmesh.BH(source_boundary_elements(ii),:),2), <span class="string">'r'</span>, <span class="string">'LineWidth'</span>,4.0);
    h2=plot(vmcmesh.r(vmcmesh.BH(detector_boundary_elements(ii),:),1), <span class="keyword">...</span>
            vmcmesh.r(vmcmesh.BH(detector_boundary_elements(ii),:),2), <span class="string">'b'</span>, <span class="string">'LineWidth'</span>,4.0);
<span class="keyword">end</span>

h3 = plot(Q(:, 1),Q(:,2),<span class="string">'ro'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'r'</span>);
h4 = plot(M(:, 1),M(:,2),<span class="string">'bs'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'b'</span>);

title(<span class="string">'Source/detector setup'</span>);
legend([h1 h2 h3 h4], {<span class="string">'ValoMC source'</span>, <span class="string">'ValoMC detector'</span>, <span class="string">'Toast source'</span>, <span class="string">'Toast detector'</span>});
hold <span class="string">off</span>
</pre><img alt="" hspace="5" src="toasttest_01.png" vspace="5"/> <h2 id="5">Solve the FEM system with Toast</h2><p>The system matrix is constructed manually using 2D coefficients (by default, Toast uses formulas derived from the radiative transfer equation for 3D geometry). For more detailed information about 2D and 3D coefficients, see e.g. T. Tarvainen: Computational Methods for Light Transport in Optical Tomography, PhD thesis, University of Kuopio, 2006.</p><pre class="codeinput"><span class="comment">% Create isotropic sources</span>
qvec = toastmesh.Qvec(<span class="string">'Isotropic'</span>,<span class="string">'Point'</span>);

<span class="comment">% To obtain comparable results, the measurement vectors have a sharp</span>
<span class="comment">% Gaussian profile (a narrow detector). Conversion factor between fluence</span>
<span class="comment">% and exitance is 2/pi in 2D</span>
mvec = 2/pi*toastmesh.Mvec(<span class="string">'Gaussian'</span>,0.5,0);

<span class="comment">% 2D diffusion coefficient</span>
toast_kap = 1./(2.*(toast_mua+toast_mus));

S1 = toastmesh.SysmatComponent(<span class="string">'PFF'</span>,toast_mua);
S2 = toastmesh.SysmatComponent(<span class="string">'PDD'</span>,toast_kap);

<span class="comment">% The boundary term is multiplied by 2/pi in 2D</span>
S3 = toastmesh.SysmatComponent (<span class="string">'BndPFF'</span>, ones(nnd,1)*2/pi);
K = S1+S2+S3;

Phi = K\(qvec);                <span class="comment">% solve the fluence</span>
Y_toast  = mvec.' * Phi;       <span class="comment">% compute the exitance on each detector</span>
</pre><h2 id="6">Solve the photon transport problem with ValoMC</h2><p>The source is relocated 16 times and the exitance at each 16 detector is stored to build a similar source/detector matrix as in the original example.</p><pre class="codeinput">Y_vmc = ones(nq,nq);
<span class="keyword">for</span> ii=1:16
   disp([<span class="string">'Starting simulation '</span> num2str(ii) <span class="string">' out of '</span> num2str(nq)]);
   options.photon_count = 1e8;            <span class="comment">% number of photon packets</span>
   vmcboundary.lightsource(:) = {<span class="string">'none'</span>}; <span class="comment">% erase all previous light sources</span>
   <span class="comment">% use a collimated light source</span>
   vmcboundary.lightsource(source_boundary_elements(ii)) = {<span class="string">'direct'</span>};
   vmcsolution = ValoMC(vmcmesh, vmcmedium, vmcboundary, options);
   <span class="comment">% build the solution matrix column by column</span>
   Y_vmc(:,ii) = vmcsolution.boundary_exitance(detector_boundary_elements(:));
<span class="keyword">end</span>
</pre><pre class="codeoutput">Starting simulation 1 out of 16
                 ValoMC-2D
--------------------------------------------
  Version:  v1.0b-118-g853f111
  Revision: 131
  OpenMP enabled                     
  Using 16 threads
--------------------------------------------
Initializing MC2D...
Computing... 
...done

Done
Starting simulation 2 out of 16
                 ValoMC-2D
--------------------------------------------
  Version:  v1.0b-118-g853f111
  Revision: 131
  OpenMP enabled                     
  Using 16 threads
--------------------------------------------
Initializing MC2D...
Computing... 
...done

Done
Starting simulation 3 out of 16
                 ValoMC-2D
--------------------------------------------
  Version:  v1.0b-118-g853f111
  Revision: 131
  OpenMP enabled                     
  Using 16 threads
--------------------------------------------
Initializing MC2D...
Computing... 
...done

Done
Starting simulation 4 out of 16
                 ValoMC-2D
--------------------------------------------
  Version:  v1.0b-118-g853f111
  Revision: 131
  OpenMP enabled                     
  Using 16 threads
--------------------------------------------
Initializing MC2D...
Computing... 
...done

Done
Starting simulation 5 out of 16
                 ValoMC-2D
--------------------------------------------
  Version:  v1.0b-118-g853f111
  Revision: 131
  OpenMP enabled                     
  Using 16 threads
--------------------------------------------
Initializing MC2D...
Computing... 
...done

Done
Starting simulation 6 out of 16
                 ValoMC-2D
--------------------------------------------
  Version:  v1.0b-118-g853f111
  Revision: 131
  OpenMP enabled                     
  Using 16 threads
--------------------------------------------
Initializing MC2D...
Computing... 
...done

Done
Starting simulation 7 out of 16
                 ValoMC-2D
--------------------------------------------
  Version:  v1.0b-118-g853f111
  Revision: 131
  OpenMP enabled                     
  Using 16 threads
--------------------------------------------
Initializing MC2D...
Computing... 
...done

Done
Starting simulation 8 out of 16
                 ValoMC-2D
--------------------------------------------
  Version:  v1.0b-118-g853f111
  Revision: 131
  OpenMP enabled                     
  Using 16 threads
--------------------------------------------
Initializing MC2D...
Computing... 
...done

Done
Starting simulation 9 out of 16
                 ValoMC-2D
--------------------------------------------
  Version:  v1.0b-118-g853f111
  Revision: 131
  OpenMP enabled                     
  Using 16 threads
--------------------------------------------
Initializing MC2D...
Computing... 
...done

Done
Starting simulation 10 out of 16
                 ValoMC-2D
--------------------------------------------
  Version:  v1.0b-118-g853f111
  Revision: 131
  OpenMP enabled                     
  Using 16 threads
--------------------------------------------
Initializing MC2D...
Computing... 
...done

Done
Starting simulation 11 out of 16
                 ValoMC-2D
--------------------------------------------
  Version:  v1.0b-118-g853f111
  Revision: 131
  OpenMP enabled                     
  Using 16 threads
--------------------------------------------
Initializing MC2D...
Computing... 
...done

Done
Starting simulation 12 out of 16
                 ValoMC-2D
--------------------------------------------
  Version:  v1.0b-118-g853f111
  Revision: 131
  OpenMP enabled                     
  Using 16 threads
--------------------------------------------
Initializing MC2D...
Computing... 
...done

Done
Starting simulation 13 out of 16
                 ValoMC-2D
--------------------------------------------
  Version:  v1.0b-118-g853f111
  Revision: 131
  OpenMP enabled                     
  Using 16 threads
--------------------------------------------
Initializing MC2D...
Computing... 
...done

Done
Starting simulation 14 out of 16
                 ValoMC-2D
--------------------------------------------
  Version:  v1.0b-118-g853f111
  Revision: 131
  OpenMP enabled                     
  Using 16 threads
--------------------------------------------
Initializing MC2D...
Computing... 
...done

Done
Starting simulation 15 out of 16
                 ValoMC-2D
--------------------------------------------
  Version:  v1.0b-118-g853f111
  Revision: 131
  OpenMP enabled                     
  Using 16 threads
--------------------------------------------
Initializing MC2D...
Computing... 
...done

Done
Starting simulation 16 out of 16
                 ValoMC-2D
--------------------------------------------
  Version:  v1.0b-118-g853f111
  Revision: 131
  OpenMP enabled                     
  Using 16 threads
--------------------------------------------
Initializing MC2D...
Computing... 
...done

Done
</pre><h2 id="7">Plot the solutions</h2><pre class="codeinput">figure(<span class="string">'rend'</span>,<span class="string">'painters'</span>,<span class="string">'pos'</span>,[10 10 1200 400])

subplot(1,2,1)
imagesc(log(Y_toast));
xlabel(<span class="string">'source index q'</span>);
ylabel(<span class="string">'detector index m'</span>);
axis <span class="string">equal</span> <span class="string">tight</span>;
colorbar
title(<span class="string">'Toast result'</span>);

<span class="comment">% Display boundary profile</span>

subplot(1,2,2)
imagesc(log(Y_vmc));
xlabel(<span class="string">'source index q'</span>);
ylabel(<span class="string">'detector index m'</span>);
axis <span class="string">equal</span> <span class="string">tight</span>;
colorbar
title(<span class="string">'ValoMC result'</span>);
hold <span class="string">off</span>;
</pre><img alt="" hspace="5" src="toasttest_02.png" vspace="5"/> <h2 id="8">Plot the measurement profile as a function of source-detector separation</h2><p>Note that because of the differences between the diffusion approximation and radiative transport theory, discretization errors as well as the stochastic nature of the Monte Carlo simulations, the 16 measurement profiles do not fully coincide.</p><pre class="codeinput">figure
hold <span class="string">on</span>

angle = 360/32:360/16:360;

<span class="keyword">for</span> profile_number=1:16

   h1=plot(angle, log(circshift((Y_vmc(:,profile_number)),-(profile_number-1))),<span class="string">'x-'</span>);
   h2=plot(angle, log(circshift((Y_toast(:,profile_number)),-(profile_number-1))),<span class="string">'o-'</span>);

   axis([10 350 -15 -2]);
   xlabel(<span class="string">'angular source-detector separation'</span>);
   ylabel(<span class="string">'exitance log(W/mm)'</span>);

<span class="keyword">end</span>

legend([h1 h2], {<span class="string">'ValoMC exitance'</span>, <span class="string">'Toast exitance'</span>});


hold <span class="string">off</span>
</pre><img alt="" hspace="5" src="toasttest_03.png" vspace="5"/> <p class="footer"><br/><a href="http://www.mathworks.com/products/matlab/">Published with MATLABÂ® R2016b</a><br/></p></div>
    </div>
</div>
</font>
  </div>

<script>


document.body.style.fontSize = (screen.width*0.01).toString() + "px";

document.getElementsByClassName("bottomhalf")[0].style.fontSize = (screen.width*0.01).toString() + "px"

var toggler = document.getElementsByClassName("caret");
var i;

toggler[0].parentElement.querySelector(".nested").classList.toggle("active");
toggler[0].classList.toggle("caret-down");

for (i = 1; i < toggler.length; i++) {
  
    if (localStorage.getItem("vmenutoggler" + i.toString())) {
        myvalue = localStorage.getItem("vmenutoggler" + i.toString());
        if(myvalue) {
          toggler[i].parentElement.querySelector(".nested").classList.toggle("active");
          toggler[i].classList.toggle("caret-down");
         }
    }
}

for (i = 0; i < toggler.length; i++) {
  toggler[i].mynumber = i;
  toggler[i].addEventListener("click", function() {
    this.parentElement.querySelector(".nested").classList.toggle("active");
    if(this.classList.toggle("caret-down")) {
       localStorage.setItem("vmenutoggler" + this.mynumber.toString(), "true");
    } else {
       localStorage.removeItem("vmenutoggler" + this.mynumber.toString());
    }
  });
}

</script>

<br>
<br> </div><footer> <hr> <p>Last updated: Tue Feb 26 10:37:00 EET 2019 by aleksle</p></footer> </body> </html>

